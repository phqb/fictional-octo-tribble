<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha256-k2WSCIexGzOj3Euiig+TlR8gA0EmPjuc79OEeY5L45g=" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <title>Hand-written digits regconization</title>
    <style>
        @media screen and (min-width: 340px) {
            body {
                padding: 10px;
            }
        }
        #content {
            max-width: 420px;
            margin-left: auto;
            margin-right: auto;
        }
        #drwCanvas, #tmpCanvas {
            border: 2px solid gray;
        }
        #loadingMask {
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            position: absolute;
            background: white;
            z-index: 98;
        }
        #initLoading {
            background: lightgray;
            width: 64px;
            height: 64px;
            position: fixed;
            top: calc(50% - 32px);
            left: calc(50% - 32px);
            border-radius: 100%;
            z-index: 99;
        }
        @keyframes expandCircle {
            0% {
                width: 0;
                height: 0;
            }
            100% {
                width: 100%;
                height: 100%;
            }
        }
        #initLoading::before {
            content: ' ';
            background: rgba(128, 128, 128, 0.5);
            width: 32px;
            height: 32px;
            position: fixed;
            top: calc(50% - 32px);
            left: calc(50% - 32px);
            border-radius: 100%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: expandCircle 1s ease-in-out infinite;
        }
        #logger {
            padding: 8px;
            width: 100%;
            font-family: monospace;
            color: gray;
        }
  </style>
</head>
<body>
    <div id="loadingMask"></div>
    <div id="initLoading"></div>
    <script src="./model.js"></script>
    <script>
        (function(){
            let loading = document.getElementById('initLoading')
            let mask = document.getElementById('loadingMask')
            let checkModelLoaded = setInterval(function() {
                if (MNIST_TRAINED_MODEL_ONE_REST && MNIST_TRAINED_MODEL_ONE_ONE) {
                    clearInterval(checkModelLoaded)
                    loading.parentElement.removeChild(loading)
                    mask.parentElement.removeChild(mask)
                }
            }, 50)
        })()
    </script>
    <div id="content">
        <h1>Hand-written digits regconization</h1>
        <br>
        <div class="btn-group" role="group">
            <button id="oneVsRestBtn" type="button" class="btn btn-primary">One vs Rest (91.76%)</button>
            <button id="oneVsOneBtn" type="button" class="btn btn-secondary">One vs One (92.46%)</button>
        </div>
        <br><br>
        <center>
            <canvas id="drwCanvas" width="308" height="308"></canvas>
            <br>
            <small style="vertical-align: middle;">Preprocessed image</small>
            <br>
            <canvas id="tmpCanvas" width="28" height="28"></canvas>
            <h2 id="resultText"></h2>
            <br>
            <div>
                <button id="clearCanvasBtn" type="button" class="btn btn-danger">Clear</button>
                <button id="regconizeDigitBtn" type="button" class="btn btn-primary">Regconize</button>
            </div>
        </center>
        <br><br>
        <div id="logger"></div>
        <script>
            'use strict'

            /**
            Drawing script is referenced by http://jsfiddle.net/yB3Kr/
            */

            var LINE_WITDH = 16
            var curX = 0
            var curY = 0
            var lastX = 0
            var lastY = 0
            var going = false

            var drwCanvas = document.getElementById('drwCanvas')
            var drawingCtx = drwCanvas.getContext('2d')

            var tmpCanvas = document.getElementById('tmpCanvas')
            var tmpCtx = tmpCanvas.getContext('2d')

            var loggerText = document.getElementById('logger')
            var resultText = document.getElementById('resultText')

            function drawPoint(ctx, x, y) {
                var gradient = ctx.createRadialGradient(x, y, 0, x, y, LINE_WITDH)
                gradient.addColorStop(0, 'rgba(0, 0, 0, 1)')
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)')

                ctx.beginPath()
                ctx.arc(x, y, LINE_WITDH, 0, 2 * Math.PI)
                ctx.fillStyle = gradient
                ctx.fill()
                ctx.closePath()
            }

            function startDrawing(e) {
                e.preventDefault()
                going = true
                var x = e.clientX
                var y = e.clientY
                if (e.touches) {
                    x = e.touches[0].clientX
                    y = e.touches[0].clientY
                }
                var rect = drwCanvas.getBoundingClientRect()
                lastX = x - rect.left
                lastY = y - rect.top
                drawPoint(drawingCtx, lastX, lastY)
            }

            drwCanvas.addEventListener('mousedown', startDrawing)
            drwCanvas.addEventListener('touchstart', startDrawing)

            function stopDrawing(e) {
                e.preventDefault()
                going = false
            }

            drwCanvas.addEventListener('mouseup', stopDrawing)
            drwCanvas.addEventListener('touchend', stopDrawing)

            function onDrawing(e) {
                e.preventDefault()
                if (going) {
                    var x = e.clientX
                    var y = e.clientY
                    if (e.touches) {
                        x = e.touches[0].clientX
                        y = e.touches[0].clientY
                    }
                    var rect = drwCanvas.getBoundingClientRect()
                    curX = x - rect.left
                    curY = y - rect.top

                    var dis = Math.sqrt(Math.pow(lastX - curX, 2) + Math.pow(lastY - curY, 2))

                    for (var i = 0; i < dis; ++i) {
                        var s = i / dis
                        drawPoint(drawingCtx, lastX * s + curX * (1 - s), lastY * s + curY * (1 - s))
                    }

                    lastX = curX
                    lastY = curY
                }
            }

            drwCanvas.addEventListener('mousemove', onDrawing)
            drwCanvas.addEventListener('touchmove', onDrawing)

            $('#clearCanvasBtn').click(function (e) {
                drawingCtx.clearRect(0, 0, drwCanvas.width, drwCanvas.height)
                drwCanvas.width = drwCanvas.width
                drwCanvas.height = drwCanvas.height

                tmpCtx.clearRect(0, 0, tmpCanvas.width, tmpCanvas.height)
                tmpCanvas.width = tmpCanvas.width
                tmpCanvas.height = tmpCanvas.height

                resultText.innerText = ''
                loggerText.innerText = ''
            })

            $('#oneVsRestBtn').click(function (e) {
                classify = oneVsRestClassify
                $(this).addClass('btn-primary')
                $('#oneVsOneBtn').removeClass('btn-primary')
            })

            $('#oneVsOneBtn').click(function (e) {
                classify = oneVsOneClassify
                $(this).addClass('btn-primary')
                $('#oneVsRestBtn').removeClass('btn-primary')
            })

            $('#regconizeDigitBtn').click(function (e) {
                regconizeDigitBtn.innerText = 'Converting image'

                var x = 0, y = 0, alpha = 0

                var minX = Number.POSITIVE_INFINITY,
                    maxX = Number.NEGATIVE_INFINITY
                var minY = Number.POSITIVE_INFINITY,
                    maxY = Number.NEGATIVE_INFINITY

                var imageData = drawingCtx.getImageData(0, 0, drwCanvas.width, drwCanvas.height).data

                for (y = 0; y < drwCanvas.height; ++y) {
                    for (x = 0; x < drwCanvas.width; ++x) {
                        alpha = imageData[(drwCanvas.width * y + x) * 4 + 3]
                        if (alpha > 128) {
                            minX = Math.min(minX, x)
                            maxX = Math.max(maxX, x)
                            minY = Math.min(minY, y)
                            maxY = Math.max(maxY, y)
                        }
                    }
                }

                var w = Math.round((maxX - minX + 1) * (1.0 * (tmpCanvas.width - 8) / drwCanvas.width))
                var paddingLeft = Math.round((tmpCanvas.width - 8 - w) / 2)

                tmpCtx.clearRect(0, 0, tmpCanvas.width, tmpCanvas.height)
                tmpCtx.drawImage(drwCanvas, minX, minY, maxX - minX + 1, maxY - minY + 1, 0, 0, w, tmpCanvas.height - 8)

                var imageMatrix = []
                for (y = 0; y < tmpCanvas.height; ++y) {
                    imageMatrix.push([])
                    for (x = 0; x < tmpCanvas.width; ++x) {
                        imageMatrix[y].push(tmpCtx.getImageData(y, x, 1, 1).data[3])
                    }
                }

                var center = center_of_mass(imageMatrix)
                var deltaX = 14 - center[0]
                var deltaY = 14 - center[1]


                var tmpImageData = tmpCtx.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height)
                tmpCtx.clearRect(0, 0, tmpCanvas.width, tmpCanvas.height)
                tmpCtx.putImageData(tmpImageData, deltaX, deltaY)

                var tmpCanvasData = tmpCtx.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height).data

                var imageBytes = []

                for (var i = 0; i < tmpCanvasData.length; i += 4) {
                    imageBytes.push(tmpCanvasData[i + 3])
                }

                imageBytes.push(1)

                window.CURENT_IMAGE_BYTES = imageBytes

                regconizeDigitBtn.innerText = 'Regconizing'
                classify(imageBytes)
                regconizeDigitBtn.innerText = 'Regconize'
            })

            function oneVsOneClassify(X) {
                var W = MNIST_TRAINED_MODEL_ONE_ONE
                var votes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                for (var p = 0; p < 9; ++p) {
                    for (var n = p + 1; n < 10; ++n) {
                        var w = W[p + '' + n]
                        var score = 0
                        for (var i = 0; i < 785; ++i) {
                            score += w[i] * X[i]
                        }
                        if (score > 0) {
                            votes[p] += 1
                        } else if (score < 0) {
                            votes[n] += 1
                        }
                    }
                }

                loggerText.innerText = ''

                var maxVote = 0
                var clz = -1
                for (var c = 0; c < 10; ++c) {
                    if (votes[c] > maxVote) {
                        maxVote = votes[c]
                        clz = c
                    }

                    loggerText.innerText += 'Class ' + c + ': ' + votes[c] + ' vote(s).\n'
                }
                loggerText.innerText += 'The most voted class is ' + clz

                resultText.innerText = clz
            }

            function oneVsRestClassify(X) {
                var W = MNIST_TRAINED_MODEL_ONE_REST

                if (X.length != W[0].length) {
                  console.log('Invalid dimension')
                  return
                }

                var clz = -1
                var maxScore = Number.NEGATIVE_INFINITY

                loggerText.innerText = ''
                for (var w = 0; w < 10; ++w) {
                    var score = 0
                    for (var i = 0; i < 785; ++i) {
                        score += W[w][i] * X[i]
                    }
                    var norm = 0
                    for (var _i = 0; _i < 784; ++_i) {
                        norm += Math.pow(W[w][_i], 2)
                    }
                    score /= Math.sqrt(norm)

                    loggerText.innerText += 'Class ' + w + ', score = ' + score + '\n'

                    if (score > maxScore) {
                        maxScore = score
                        clz = w
                    }
                }

                loggerText.innerText += 'The most confident class is ' + clz
                resultText.innerText = clz
            }

            var classify = oneVsRestClassify

            function center_of_mass(input) {
                var width = input[0].length
                var height = input.length
                var r = 0
                var c = 0

                var normalizer = 0
                for (r = 0; r < height; ++r) {
                    for (c = 0; c < width; ++c) {
                        normalizer += input[r][c]
                    }
                }

                var xMesh = 0
                var yMesh = 0
                for (r = 0; r < height; ++r) {
                    for (c = 0; c < width; ++c) {
                        xMesh += input[r][c]*r
                        yMesh += input[r][c]*c
                    }
                }

                return[xMesh/normalizer, yMesh/normalizer]
            }
        </script>
        <br><br><br>
        <small style="color: gray">make by phqb with ♥</small>
    </div>
</body>
</html>
